module gen/java-ast/func_body

imports

  libspoofax/stratego/debug
  
  src-gen/signatures/-
  signatures/-

  statics
  statics/constructors

  gen/java-ast/func_def
  gen/java-ast/binder
  gen/java-ast/type
  gen/java-ast/ast-util
  gen/idtype-tuples
  gen/debug
  gen/util

rules

  // tries to apply p2j-ast-exp, returns ""
  try-p2j-ast-exp = pie-try-debug(p2j-ast-exp|"p2j-ast-exp") <+ !([], NewInstance(None(), [], "Object", [], None(), []))

rules // Expression composition

  // p2j-ast-exp: Pie to Java AST expressions
  // Takes a Pie AST Expression node and compiles it to a pair of
  // (List of Java statements, Java Node with an expression for the value of the Pie AST node)
  p2j-ast-exp:
    e@Block(exps) -> result
    with
      numExps              := <length> exps
    ; restExps             := <take(|<dec> numExps)> exps
    ; restStmts            := <map(try-p2j-ast-exp); map(Fst); concat> restExps
    ; lastExp              := <last> exps
    ; (lastStmts, lastVal) := <try-p2j-ast-exp> lastExp
    ; stmts                := <concat> [restStmts, lastStmts]
    ; blockResultVal       := <newname> "blockResult"
    ; ty                   := <p2j-ast-type-sig> <pie-ast-type> e
    ; resultStmts          := [
      LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDecl(Id(blockResultVal))])),
      Block(<concat> [
        stmts,
        [ ExpressionStatement(Assign(ExpressionName(Id(blockResultVal)), lastVal)) ]
      ])
    ]
    ; result                    := (resultStmts, blockResultVal)

  p2j-ast-exp: EmptyBlock() -> <p2j-ast-exp> UnitLit()

rules // Unary expressions

  p2j-ast-exp:
    ToNullable(exp) -> <try-p2j-ast-exp> exp // non-primitive Java types are always nullable

  p2j-ast-exp:
    n@ToNonNullable(exp) -> result
    with
      <add-import> "java.util.Objects"
    ; <add-import> "mb.pie.api.ExecException"
    ; (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; tmpVarName         := <newname> "exp"
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> n
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [VariableDecl(Id(tmpVarName))]
          ))
        , Try(
            Block(
              [ ExpressionStatement(Assign(
                  ExpressionName(Id(tmpVarName))
                , InvokeQExp(ExpressionName("Objects"), None(), "requireNonNull", [expVal])
                ))
              ]
            )
          , [ Catch(
                CatchParam(
                  []
                , CatchType(ClassType(Id("NullPointerException"), None()), [])
                , VariableDecl(Id("ex"))
                )
              , Block(
                  [ Throw(NewInstance(None(), [], Id("ExecException"), [], None(), [
                      StringLiteral($["Tried to cast a null value to NonNullable"])
                    , ExpressionName(Id("ex"))
                    ]))
                  ]
                )
              )
            ]
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [tmpVarName];
        //   try {
        //     [tmpVarName] = Objects.requireNonNull([expVal]);
        //   } catch (NullpointerException ex) {
        //     throw new ExecException("Tried to cast a null value to NonNullable", ex);
        //   }
      ]
    ; result             := (stmts, tmpVarName)


  p2j-ast-exp:
    Not(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; result             := (expStmts, Not(expVal))

rules // Binary expressions

  // p2j-ast-binexp(combine-vals):
  //   (lExp, rExp) -> (Java statements, Java expression value AST node)
  // a general function for handline a binexp.
  // It takes a strategy combine-vals to combine the values of both sides
  p2j-ast-binexp(combine-vals):
    (lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; stmts             := <concat> [lStmts, rStmts]
    ; exp               := <combine-vals> (lExpVal, rExpVal)
    ; result            := (stmts, exp)

  p2j-ast-exp: Eq(lExp, rExp) -> <p2j-ast-binexp(
      \(e1, e2) -> InvokeQExp(ExpressionName(Id("Objects")), None(), Id("equals"), [e1, e2])\
    )> (lExp, rExp)
    with
      <add-import> "java.util.Objects"
  p2j-ast-exp: Neq(lExp, rExp) -> <p2j-ast-binexp(
      \(e1, e2) -> Not(InvokeQExp(ExpressionName(Id("Objects")), None(), Id("equals"), [e1, e2]))\
    )> (lExp, rExp)
    with
      <add-import> "java.util.Objects"
  p2j-ast-exp: Lor(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyOr(e1, e2)\)> (lExp, rExp)
  p2j-ast-exp: Land(lExp, rExp) -> <p2j-ast-binexp(\(e1, e2) -> LazyAnd(e1, e2)\)> (lExp, rExp)

rules // Control flow

  p2j-ast-exp:
    If(condExp, branch) -> result
    with
      (condStmts, condExpVal) := <try-p2j-ast-exp> condExp
    ; (branchStmts, _)        := <try-p2j-ast-exp> branch
    ; stmts                   := <concat> [condStmts, [If(condExpVal, Block(branchStmts))]]
    ; exp                     := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                  := (stmts, exp)

  p2j-ast-exp:
    e@IfElse(condExp, trueExp, falseExp) -> result
    with
      (condStmts, condVal)   := <try-p2j-ast-exp> condExp
    ; (trueStmts, trueVal)   := <try-p2j-ast-exp> trueExp
    ; (falseStmts, falseVal) := <try-p2j-ast-exp> falseExp
    ; resultName             := <newname> "ifResult"
    ; trueBlockStmts         := <concat> [trueStmts, [ExpressionStatement(Assign(ExpressionName(Id(resultName)), trueVal))]]
    ; falseBlockStmts        := <concat> [falseStmts, [ExpressionStatement(Assign(ExpressionName(Id(resultName)), falseVal))]]
    ; ty                     := <p2j-ast-type-sig> <pie-ast-type> e
    ; stmts                  := <concat> [
      condStmts,
      [
        LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDecl(Id(resultName))])),
        IfElse(condVal, Block(trueBlockStmts), Block(falseBlockStmts))
      ]]
    ; result                 := (stmts, resultName)

  p2j-ast-exp:
    Add(lExp, rExp) -> result
    with
      (lStmts, lExpVal) := <try-p2j-ast-exp> lExp
    ; (rStmts, rExpVal) := <try-p2j-ast-exp> rExp
    ; lType             := <pie-ast-type> lExp
    ; rType             := <pie-ast-type> rExp
    ; (expStmts, exp)   := <p2j-ast-add(|lType, rType)> (lExpVal, rExpVal)
    ; stmts             := <concat> [lStmts, rStmts, expStmts]
    ; result            := (stmts, exp)

  // p2j-ast-add(|lType, rType): (lExp, rExp) ->
  //   (List of Java AST statements, Java expression AST Node)
  // Helper function that converts the Add into the correct AST Node
  // based on the types of the left and right side (lType and rType)
  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], Add(lExp, rExp))
    where
      (IntType(), IntType()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], Add(lExp, rExp))
    where
      (StrType(), _) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> result
    where
      (PathType(), PathType()) := (lType, rType)
    with
      <add-import> "mb.resource.ResourceRuntimeException"
    ; tmpResultName := <newname> "addResult"
    ; stmts         := [
        LocVarDeclStm(LocalVarDecl(
          [Final()]
        , ClassType(Id("FSPath"), None())
        , [VariableDecl(Id(tmpResultName))]
        ))
      , Try(
          Block(
            [ ExpressionStatement(Assign(
                ExpressionName(Id(tmpResultName))
              , InvokeQExp(lExp, None(), Id("appendRelativePath"), [rExp])
              ))
            ]
          )
        , [ Catch(
              CatchParam(
                []
              , CatchType(ClassType(Id("ResourceRuntimeException"), None()), [])
              , VariableDecl(Id("e"))
              )
            , Block([Throw(
                NewInstance(
                  None()
                , []
                , Id("ExecException")
                , []
                , None()
                , [ StringLiteral($["Could not append path: it is an absolute path"])
                  , ExpressionName(Id("e"))
                  ]
                )
              )])
            )
          ]
        )
      ]
      // Note: meaning of this AST:
      //   final FSPath [tmpResultName];
      //   try {
      //     [tmpResultName] = [lExp].appendRelativePath([rExp]);
      //   } catch (ResourceRuntimeException e) {
      //     throw new ExecException("Could not append path: it is an absolute path", e);
      //   }
    ; exp           := tmpResultName
    ; result        := (stmts, exp)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([], InvokeQExp(lExp, None(), Id("appendOrReplaceWithPath"), [rExp]))
    // Note: meaning of this AST: [lExp].appendSegment([rExp])
    where
      (PathType(), StrType()) := (lType, rType)

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([],
      InvokeQExp(
        InvokeQExp(
          ExpressionName(Id("Stream"))
        , None()
        , Id("concat")
        , [ InvokeQExp(lExp, None(), Id("stream"), [])
          , InvokeQExp(
              ExpressionName(Id("Stream"))
            , None()
            , Id("of")
            , [rExp]
            )
          ]
        )
      , None()
      , Id("collect")
      , [ InvokeQExp(
            ExpressionName(Id("Collectors"))
          , None()
          , Id("toCollection")
          , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
          )
        ]
      )
    )
    // Note: meaning of this AST:
    //   Stream.concat(([lExp]).stream(), Stream.of([rExp])).collect(Collectors.toCollection(ArrayList::new))
    where
      (ListType(a), a) := (lType, rType)
    with
      <add-import> "java.util.ArrayList"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.stream.Stream"

  p2j-ast-add(|lType, rType):
    (lExp, rExp) -> ([],
      InvokeQExp(
	    InvokeQExp(
	      ExpressionName(Id("Stream"))
	    , None()
	    , Id("concat")
	    , [ InvokeQExp(lExp, None(), Id("stream"), [])
	      , InvokeQExp(rExp, None(), Id("stream"), [])
	      ]
	    )
	  , None()
	  , Id("collect")
	  , [ InvokeQExp(
	        ExpressionName(Id("Collectors"))
	      , None()
	      , Id("toCollection")
	      , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
	      )
	    ]
	  )
	)
    // Note: meaning of this AST:
    // Stream.concat(([lExp]).stream(), ([rExp]).stream()).collect(Collectors.toCollection(ArrayList::new))]
    where
      (ListType(a), ListType(a)) := (lType, rType)
    with
      <add-import> "java.util.ArrayList"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.stream.Stream"

  p2j-ast-exp:
    e@ListComprehension(mapExp, binder, listExp) -> result
    with
      <add-import> "java.util.ArrayList"
    ; (listStmts, listExpVal) := <try-p2j-ast-exp> listExp
    ; ListType(pieElemTy)     := <pie-ast-type> listExp
    ; elemTy                  := <p2j-ast-type-sig> pieElemTy
    ; (mapStmts, mapExpVal)   := <try-p2j-ast-exp> mapExp
    ; (assignments, varId)    := <bind-tuples-to-ast-assignments> (binder, pieElemTy)
    ; comprehensionTmpVarName := <newname> "comprehensionResult"
    ; innerStmts              := <concat> [
        assignments,
        mapStmts,
        [ ExpressionStatement(
            InvokeQExp(
              ExpressionName(
                Id(comprehensionTmpVarName))
              , None()
              , Id("add")
              , [ mapExpVal ]
            )
          )
        ]
      ]
    ; ty                      := <p2j-ast-type-sig> <pie-ast-type> e
    ; stmts                   := <concat> [
        listStmts,
        [ 
          LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(comprehensionTmpVarName))
              , NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [])
              )
            ]
          ))
        , ForEach(
            []
          , <java-classType-to-unannType> elemTy
          , VariableDecl(Id(varId))
          , listExpVal
          , Block(innerStmts)
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [comprehensionTmpVarName] = new ArrayList<>();
        //   for ([elemTy] [elemName] : [listExpVal]) {
        //     [innerStmts]
        //   }
      ]
    ; result                     := (stmts, comprehensionTmpVarName)

rules // Binding

  p2j-ast-exp:
    e@ValDec(binder, exp) -> result
    with
      pieTy                := <pie-ast-type> binder
    ; expTy                := <p2j-ast-type-sig> pieTy
    ; (expStmts, expVal)   := <try-p2j-ast-exp> exp
    ; (assignments, varId) := <bind-tuples-to-ast-assignments> (binder, pieTy)
    ; stmts                := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> expTy
          , [VariableDeclInit(VariableDecl(Id(varId)), expVal)]
          ))
        ]
      , assignments
      ]
    ; resultExp            := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result               := (stmts, resultExp)

  // bind-tuples-to-assignments:
  // (Pie Binder (Bind or TBind), Pie ExpressionType) -> (assignments, varName)
  bind-tuples-to-ast-assignments:
    (SingleBinder(bind), _) -> ([], <p2j-ast-bind> bind)

  bind-tuples-to-ast-assignments:
    (TupleBinder(binds), expTy) -> result
    with
      varIds         := <map(p2j-ast-bind)> binds
    ; TupleType(tys) := expTy
    ; javaTys        := <map(p2j-ast-type-sig)> tys
    ; bindList       := <zip> (varIds, javaTys)
    ; tmpVar         := <newname> "tmpTupleVar"
    ; assignments    := <nmap-par(bind-tuple-to-ast | 1, tmpVar)> bindList
    ; result         := (assignments, tmpVar)

  // nmap that passes an extra parameter to the strategy
  nmap-par(s : Int * c * a -> b | i, par) =
    ?[] + [s(|i,par) | nmap-par(s | <inc> i, par)]

  bind-tuple-to-ast(|i, tmpVar):
    (varId, ty) -> LocVarDeclStm(LocalVarDecl(
      [Final()]
    , <java-classType-to-unannType> ty
    , [ VariableDeclInit(
          VariableDecl(Id(varId))
        , InvokeQExp(ExpressionName(Id(tmpVar)), None(), Id($[component[i]]), [])
        )
      ]
    ))

rules // References

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName(Id(varId)))> r)
    where
      LocalVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId

  p2j-ast-exp:
    Ref(varId) -> <fail> // todo: use error(|"message") instead of fail
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 0 := <InputKind>

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|ExpressionName(Id("input")))> r)
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 1 := <InputKind>

  p2j-ast-exp:
    r@Ref(varId) -> ([], <p2j-ast-ref-add-transient-val(|InvokeQExp(
      ExpressionName(Id("input")), None(), Id($[get_[varId]]), [])
    )> r)
    where
      InputVarKind() := <pie-ast-ref-prop(|"Var", "kind")> varId
    ; 2 := <InputKind>

  // p2j-ast-ref-add-transient-val(|ast): Pie Ref -> Java reference
  p2j-ast-ref-add-transient-val(|ast):
    ref -> InvokeQExp(ast, None(), Id("getValue"), [])
    where
      <p2j-ast-ref-is-transient> ref

  p2j-ast-ref-add-transient-val(|ast):
    ref -> ast
    where
      <not(p2j-ast-ref-is-transient)> ref

  // succeeds if the current term is transient
  p2j-ast-ref-is-transient =
      pie-ast-type
    ; (?DataType(<id>) <+ ?NullableType(DataType(<id>)))
    ; pie-get-property(|"mods")
    ; collect-one(?Transient())

rules // Java foreign function calls

  p2j-ast-exp:
    c@Call(moduleList, funcId, exps) -> result
    where
      JavaForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      // todo: use moduleList
      javaClassId           := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; javaMethodId          := <pie-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; callResultName        := <newname> "callResult"
    ; ty                    := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                 := <concat> [
        <concat> expsStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(callResultName))
              , InvokeQExp(ExpressionName(Id(javaClassId)), None(), Id(javaMethodId), expsVals)
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //     final [ty] [callResultName] = [javaClassId].[javaMethodId]([expsVals]);
      ]
    ; result                := (stmts, callResultName)

  p2j-ast-exp:
    c@Call(moduleList, funcId, exps) -> result
    where
      JavaForeignConstructorKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      // todo: use moduleList
      javaClassId           := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; callResultName        := <newname> "constructorResult"
    ; ty                    := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                 := <concat> [
        <concat> expsStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(callResultName))
              , NewInstance(None(), [], Id(javaClassId), [], None(), expsVals)
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //     final [ty] [callResultName] = new [javaClassId].([expsVals]);
      ]
    ; result                := (stmts, callResultName)

rules // Qualified function calls

  p2j-ast-exp:
    c@QCall(exp, funcId, argExps) -> result
    with
      (expStmts, expVal)          := <try-p2j-ast-exp> exp
    ; (argExpsStmts, argExpsVals) := <unzip> <map(try-p2j-ast-exp)> argExps
    ; callResultName              := <newname> "callResult"
    ; ty                          := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                       := <concat> [
        expStmts,
        <concat> argExpsStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(callResultName))
              , InvokeQExp(expVal, None(), Id(funcId), argExpsVals)
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [callResultName] = [expVal].[funcId]([argExpsVals]);]]
      ]
    ; result                      := (stmts, callResultName)

  // todo: originally from ImportCall. Merge with existing Call.
  p2j-ast-exp:
    c@Call(moduleList, funcId, argExps) -> result
    where
      JavaForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId                 := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; expressionNameJavaClassId   := <java-qualifiedClass-to-expressionName> <string-tokenize(|['.'])> javaClassId
    ; javaMethodId                := <pie-ast-ref-prop(|"Func", "javaMethodId")> funcId
    ; (argExpsStmts, argExpsVals) := <unzip> <map(try-p2j-ast-exp)> argExps
    ; callResultName              := <newname> "callResult"
    ; ty                          := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                       := <concat> [
        <concat> argExpsStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(callResultName))
              , InvokeQExp(expressionNameJavaClassId, None(), Id(javaMethodId), argExpsVals)
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [callResultName] = [javaClassId].[javaMethodId]([argExpsVals]);
      ]
    ; result                      := (stmts, callResultName)

  // todo: originally from ImportCall. Merge with existing Call.
  p2j-ast-exp:
    c@Call(moduleList, funcId, exps) -> result
    where
      JavaForeignConstructorKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId           := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; callResultName        := <newname> "constructorResult"
    ; ty                    := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                 := <concat> [
        <concat> expsStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(callResultName))
              , NewInstance(None(), [], Id(javaClassId), [], None(), expsVals)
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //     final [ty] [callResultName] = new [javaClassId].([expsVals]);
      ]
    ; result                := (stmts, callResultName)

  // todo: originally from ImportCall. Merge with existing Call.
  p2j-ast-exp:
    c@Call(moduleList, funcId, argExps) -> result
    where
      PieForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      <add-import> "mb.pie.api.ExecException"
    ; <add-import> "javax.inject.Provider"
    ; javaClassId              := <p2j-ast-pieFuncId-to-javaClassId> funcId
    ; (expStmts, inputArg)     := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> argExps
    ; safeJavaClassId          := <string-replace(|".", "_")> javaClassId
    ; callResultName           := <newname> "callResult"
    ; ty                       := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                    := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDecl(Id(callResultName)) ]
          ))
        , ExpressionStatement(Assign(
            ExpressionName(Id(callResultName))
          , InvokeQExp(
              ExpressionName(Id("execContext"))
            , None()
            , Id("require")
            , [ InvokeQExp(
                  ExpressionName(Id($[_[safeJavaClassId]]))
                , None()
                , Id("get")
                , []
                )
              , inputArg
              ]
            )
          ))
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName];
        //   [callResultName] = execContext.require(_[safeJavaClassId], [inputArg]);
      ]
    ; result                   := (stmts, callResultName)
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), None())])))
      ))

  // todo: originally from ImportCall. Merge with existing Call.
  p2j-ast-exp:
    c@Call(moduleList, funcId, argExps) -> result
    where
      PieFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      <add-import> "mb.pie.api.ExecException"
    ; <add-import> "javax.inject.Provider"
    ; javaClassId              := <pie-sanitize-class-id> funcId
    ; (expStmts, inputArg)     := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> argExps
    ; safeJavaClassId          := <string-replace(|".", "_")> javaClassId
    ; callResultName           := <newname> "callResult"
    ; ty                       := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                    := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDecl(Id(callResultName)) ]
          ))
        , ExpressionStatement(Assign(
            ExpressionName(Id(callResultName))
          , InvokeQExp(
              ExpressionName(Id("execContext"))
            , None()
            , Id("require")
            , [ InvokeQExp(
                  ExpressionName(Id($[_[safeJavaClassId]]))
                , None()
                , Id("get")
                , []
                )
              , inputArg
              ]
            )
          ))
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName];
        //   [callResultName] = execContext.require(_[safeJavaClassId], [inputArg]);
      ]
    ; result                   := (stmts, callResultName)
    ; fullyQualifiedModuleList := <pie-ast-ref-prop(|"Func", "qualifiedModule")> funcId
    // todo: pie-ast-ref-prop gives incorrect results if there are two functions with the same name?
    ; encompassingClassName    := <concat-strings-separator(|".")> fullyQualifiedModuleList
    ; <add-import> $[[encompassingClassName].[javaClassId]]
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), None())])))
      ))

rules // PIE function calls

  // todo: use moduleList
  p2j-ast-exp:
    c@Call(moduleList, funcId, _) -> <p2j-ast-exp-pie-call(|javaClassId)> c
    where
      PieForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId

  // todo: use moduleList
  p2j-ast-exp:
    c@Call(moduleList, funcId, _) -> <p2j-ast-exp-pie-call(|javaClassId)> c
    where
      PieFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-sanitize-class-id> funcId

  // p2j-ast-exp-pie-call(|javaClassId): Call -> (stmts, exp value)
  // Like p2j-ast-exp, but specifically for pie Calls. Is called by the strategies
  // above. javaClassId is the name of the class that represents the Pie function
  p2j-ast-exp-pie-call(|javaClassId):
   c@Call(moduleList, funcId, exps) -> result
    with
      // todo: use moduleList
      <add-import> "mb.pie.api.ExecException"
    ; <add-import> "javax.inject.Provider"
    ; (expStmts, inputArg) := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> exps
    ; safeJavaClassId      := <string-replace(|".", "_")> javaClassId
    ; callResultName       := <newname> "callResult"
    ; ty                   := <p2j-ast-type-sig> <pie-ast-type> c
    ; stmts                := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDecl(Id(callResultName)) ]
          ))
        , ExpressionStatement(Assign(
            ExpressionName(Id(callResultName))
          , InvokeQExp(
              ExpressionName(Id("execContext"))
            , None()
            , Id("require")
            , [ InvokeQExp(
                  ExpressionName(Id($[_[safeJavaClassId]]))
                , None()
                , Id("get")
                , []
                )
              , inputArg
              ]
            )
          ))
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName];
        //   [callResultName] = execContext.require(_[safeJavaClassId], [inputArg]);
      ]
    ; result                := (stmts, callResultName)
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), None())])))
      ))

  // p2j-ast-exp-pie-call-inputexp(|javaClassId): exps -> (stmts, input ast node)
  // Converts a list of Pie expressions to a list of statements and an AST node that
  // can be used as input for a Pie task. Will be either Unit, an arbitrary AST node
  // or an Input AST node for the provided JavaClass (from JavaClassId)
  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> <try-p2j-ast-exp> UnitLit()
    where
      0 := <length> exps

  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      1 := <length> exps
    with
      [exp]  := exps
    ; result := <try-p2j-ast-exp> exp

  p2j-ast-exp-pie-call-inputexp(|javaClassId):
    exps -> result
    where
      length := <length> exps
    ; <gt> (length, 1)
    with
      (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(
          None()
        , []
        , Id(javaClassId)
        , [QualifiedId([], "Input")]
        , None()
        , expsVals
        )
      // Note: meaning of this AST:
      //       new [javaClassId].Input([expsVals])
    ; result                := (stmts, exp)

  p2j-ast-exp: CreateSupplier(arg) -> result
    with
      <add-import> "mb.pie.api.Supplier"
    ; <add-import> "mb.pie.api.ValueSupplier"
    ; (argStmts, argVal) := <p2j-ast-exp> arg
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> arg
    ; supplierName       := <newname> "supplier"
    ; stmts              := <concat> [
        argStmts,
        [ LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , ClassType(
                Id("Supplier")
              , Some(TypeArguments([ty]))
              )
            , [ VariableDeclInit(
                  VariableDecl(Id(supplierName))
                , NewInstance(None(), [], "ValueSupplier", [], None(), [argVal])
                )
              ]
            )
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [supplierName] = new ValueSupplier([argVal]);
      ]
    ; result             := (stmts, supplierName)


  // todo: use moduleList
  p2j-ast-exp: t@TaskSupplier(moduleList, funcId, args) -> result
    with
      <add-import> "javax.inject.Provider"
    ; javaClassId          := <p2j-ast-pieFuncId-to-javaClassId> funcId
    ; safeJavaClassId      := <string-replace(|".", "_")> javaClassId
    ; (argStmts, inputArg) := <p2j-ast-exp-pie-call-inputexp(|javaClassId)> args
    ; callResultName       := <newname> "callResult"
    ; ty                   := <p2j-ast-type-sig> <pie-ast-type> t
    ; stmts                := <concat> [
        argStmts,
        [ LocVarDeclStm(
            LocalVarDecl(
              [Final()]
            , <java-classType-to-unannType> ty
            , [ VariableDeclInit(
                  VariableDecl(Id(callResultName))
                , InvokeQExp(
                    InvokeQExp(
                      ExpressionName(Id($[_[safeJavaClassId]]))
                    , None()
                    , Id("get")
                    , []
                    )
                  , None()
                  , Id("createSupplier")
                  , [ inputArg ]
                  )
                )
              ]
            )
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName] = [javaClassName].createSupplier([inputArg]);
      ]
    ; result               := (stmts, callResultName)
    ; rules(InjectValues :+= (
        $[_[safeJavaClassId]],
        ClassType([], Id("Provider"), Some(TypeArguments([ClassType([], Id(javaClassId), None())])))
      ))


  p2j-ast-pieFuncId-to-javaClassId: funcId -> javaClassId
    where
      PieForeignFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-ast-ref-prop(|"Func", "javaClassId")> funcId

  p2j-ast-pieFuncId-to-javaClassId: funcId -> javaClassId
    where
      PieFuncKind() := <pie-ast-ref-prop(|"Func", "kind")> funcId
    with
      javaClassId := <pie-sanitize-class-id> funcId

  p2j-ast-exp: SupplierGet(exp) -> result
    with
      <add-import> "java.io.IOException"
    ; (expStmts, expVal)  := <p2j-ast-exp> exp
    ; SupplierType(pieTy) := <pie-ast-type> exp
    ; ty                  := <p2j-ast-type-sig> pieTy
    ; callResultName      := <newname> "callResult"
    ; stmts               := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [VariableDecl(Id(callResultName))]
          ))
        , Try(
            Block(
              [ ExpressionStatement(Assign(
                  ExpressionName(Id(callResultName))
                , InvokeQExp(
                    ExpressionName(Id("execContext"))
                  , None()
                  , Id("require")
                  , [ expVal ]
                  )
                ))
              ]
            )
          , [ Catch(
                CatchParam(
                  []
                , CatchType(ClassType(Id("IOException"), None()), [])
                , VariableDecl(Id("ex"))
                )
              , Block(
                  [ Throw(NewInstance(None(), [], Id("ExecException"), [], None(), [
                      StringLiteral($["Unexpected IOException while getting value from supplier"])
                    , ExpressionName(Id("ex"))
                    ]))
                  ]
                )
              )
            ]
          )
        ]
        // Note: meaning of this AST:
        //   final [ty] [callResultName];
        //   try {
        //     [callResultName] = execContext.require([expVal]);
        //   } catch (IOException ex) {
        //     throw new ExecException("Unexpected IOException while getting value from supplier", ex);
        //   }
      ]
    ; result               := (stmts, callResultName)

rules // Path operations

  p2j-exp:
    r@RequiresPath(exp, filterOpt, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (filterOpt, stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [ ExpressionStatement(InvokeQExp(
            ExpressionName(Id("execContext"))
          , None()
          , Id("require")
          , [expVal, stamperVal]
          ))
        ]
        // Note: meaning of this AST:
        //       execContext.require([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)

  p2j-exp:
    GeneratesPath(exp, stamper) -> result
    with
      (expStmts, expVal)         := <p2j-ast-exp> exp
    ; (stamperStmts, stamperVal) := <p2j-ast-stamper> (None(), stamper)
    ; stmts                      := <concat> [
        expStmts,
        stamperStmts,
        [ ExpressionStatement(InvokeQExp(
            ExpressionName(Id("execContext"))
          , None()
          , Id("provide")
          , [expVal, stamperVal]
          ))
        ]
        // Note: meaning of this AST:
        //       execContext.provide([expVal], [stamperVal]);
      ]
    ; resultExp                  := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result                     := (stmts, resultExp)

  // p2j-stamper: (filter|None(), stamper) -> (stmts, expression value)
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("modified"), []))
    // Note: meaning of this AST: FileSystemStampers.modified()
  p2j-ast-stamper:
    (None(), Modified()) -> ([], InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("hash"), []))
    // Note: meaning of this AST: FileSystemStampers.hash()
  p2j-ast-stamper:
    (filter, Modified()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("modified"), [filterVal])
      // Note: meaning of this AST: FileSystemStampers.modified([filterVal])
    ; result             := (stmts, exp)

  p2j-ast-stamper:
    (filter, Hash()) -> result
    where
      <not(?None())> filter
    with
      (stmts, filterVal) := <p2j-ast-filter> filter
    ; exp                := InvokeQExp(ExpressionName(Id("FileSystemStampers")), None(), Id("hash"), [filterVal])
      // Note: meaning of this AST: FileSystemStampers.hash([filterVal])
    ; result             := (stmts, exp)

  p2j-ast-exp:
    l@ListPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-list|"list")> (l, exp, filterOpt)
  p2j-ast-exp:
    w@WalkPath(exp, filterOpt) ->
      <p2j-ast-dir(p2j-ast-filter-create-param-list-for-walk|"walk")> (w, exp, filterOpt)

  // p2j-ast-dir(create-param-list | funcName):
  //   (astNode, exp, filterOpt) -> (Java statements, Java expression value)
  // Combined function for both ListPath and WalkPath.
  // Input:
  // - a strategy create-params-list which is passed on to p2j-ast-filter-to-params-list.
  // - a function name to call (funcName)
  // - operates on terms that are a Triple of:
  //   + a Pie AST node (ListPath or WalkPath)
  //   + the expression from that AST node (said expression represents a path)
  //   + the filterOption from that AST node. This is also known as a matcher.
  p2j-ast-dir(create-param-list | funcName):
    (astNode, exp, filterOpt) -> result
    with
      <add-import> "mb.resource.fs.FSResource"
    ; <add-import> "java.util.stream.Collectors"
    ; <add-import> "java.util.ArrayList"
    ; (expStmts, expVal)      := <try-p2j-ast-exp> exp
    ; (matcherStmts, matcher) := <p2j-ast-filter> filterOpt
    ; funcParamList           := <p2j-ast-filter-to-params-list(create-param-list)> (filterOpt, matcher)
    ; ty                      := <p2j-ast-type-sig> <pie-ast-type> astNode
    ; expVarName              := <newname> "dirResult"
    ; stmts                   := <concat> [
        expStmts,
        matcherStmts,
        [LocVarDeclStm(LocalVarDecl([Final()], <java-classType-to-unannType> ty, [VariableDeclInit(
          VariableDecl(Id(expVarName)),
          InvokeQExp(
            InvokeQExp(
              InvokeQExp(
                InvokeQExp(ExpressionName(Id("execContext")), None(), Id("require"), [expVal])
                , None()
                , funcName
                , funcParamList
                )
            , None()
            , Id("map")
            , [MethodReferenceRType(ClassType([], Id("FSResource"), None()), None(), Id("getPath"))]
            )
          , None()
          , Id("collect")
          , [ InvokeQExp(
                ExpressionName(Id("Collectors"))
              , None()
              , Id("toCollection")
              , [MethodReferenceCType(ClassType([], Id("ArrayList"), None()), None())]
              )
            ]
          )
        )]))]
        // Note: meaning of this AST:
        //   final [ty] [expVarName] = execContext.require([expVal]).[funcName]([funcParamList])
        //   .map(FSResource::getPath)
        //   .collect(Collectors.toCollection(ArrayList::new));
      ]
    ; result                  := (stmts, expVarName)

  // p2j-ast-filter-to-params-list(create-param-list):
  //   (matcherPie, matcherJava) -> parameter list
  // creates a list of parameters for the call to the dir-function in p2j-ast-dir
  // create-param-list should be one of the p2j-filter-create-param-list-for-X strategies
  p2j-ast-filter-to-params-list(create-param-list):
    (None(), _) -> []
  p2j-ast-filter-to-params-list(create-param-list):
    (matcherPie, matcherJava) -> <create-param-list> matcherJava
    where
      <not(?None())> matcherPie

  // p2j-ast-filter-create-param-list-for-[funcName]: matcher -> param list
  // Given a Java AST node for a matcher, create a list of parameters
  // for the Pie API method funcName
  p2j-ast-filter-create-param-list-for-list:
    matcher -> [NewInstance(None(), [], Id("PathResourceMatcher"), [], None(), matcher)]
    // Note: meaning of this AST: new PathResourceMatcher([matcher])
  p2j-ast-filter-create-param-list-for-walk:
    matcher -> [
      NewInstance(None(), [], "PathResourceWalker", [], None(), [
        NewInstance(None(), [], Id("NoHiddenPathMatcher"), [], None(), [])
      ]),
      NewInstance(None(), [], Id("PathResourceMatcher"), [], None(), [matcher])
    ]
    // Note: meaning of these ASTs:
    //   new PathResourceWalker(new NoHiddenPathMatcher())
    //   new PathResourceMatcher([matcher])

  // p2j-ast-filter: Pie filter -> (stmts, Java AST expression value)
  p2j-ast-filter:
    None() -> ([], Null())
  p2j-ast-filter:
    Regex(exp) -> <p2j-ast-filter-common> ("RegexPathMatcher", exp)
  p2j-ast-filter:
    Pattern(exp) -> <p2j-ast-filter-common> ("PatternPathMatcher", exp)
  p2j-ast-filter:
    Patterns(exp) -> <p2j-ast-filter-common> ("PatternsPathMatcher", exp)
  p2j-ast-filter:
    Extension(exp) -> <p2j-ast-filter-common> ("ExtensionPathMatcher", exp)
  p2j-ast-filter:
    Extensions(exp) -> <p2j-ast-filter-common> ("ExtensionsPathMatcher", exp)

  // p2j-ast-filter-common: (Pie matcher, Pie exp) -> (stmts, Java AST expression value)
  p2j-ast-filter-common:
    (matcher, exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; resultExp          := NewInstance(None(), [], Id(matcher), [], None(), [expVal])
    // Note: meaning of this AST: new [matcher]([expVal])
    ; result                := (expStmts, resultExp)


  p2j-ast-exp:
    r@ReadPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> r
    ; readResultName     := <newname> "readResult"
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(readResultName))
              , InvokeQExp(ExpressionName(Id("Util")), None(), Id("readToString"), [expVal])
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [readResultName] = Util.readToString([expVal]);
      ]
    ; result             := (stmts, readResultName)

  p2j-ast-exp:
    e@ExistsPath(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; ty                 := <p2j-ast-type-sig> <pie-ast-type> e
    ; existsResultName   := <newname> "existsResult"
    ; stmts              := <concat> [
        expStmts,
        [ LocVarDeclStm(LocalVarDecl(
            [Final()]
          , <java-classType-to-unannType> ty
          , [ VariableDeclInit(
                VariableDecl(Id(existsResultName))
              , InvokeQExp(
                  InvokeQExp(ExpressionName(Id("Files")), None(), Id("exists"), [expVal])
                , None()
                , Id("getJavaPath")
                , []
                )
              )
            ]
          ))
        ]
        // Note: meaning of this AST:
        //       final [ty] [existsResultName] = Files.exists([expStr].getJavaPath());
      ]
    ; result             := (stmts, existsResultName)

rules // Early return and failure

  p2j-ast-exp:
    Return(exp) -> result
    with
      (expStmts, expVal) := <p2j-ast-pie-func-impl-returnvalue> exp
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; stmts              := <concat> [expStmts, [Return(expVal)]]
    ; result             := (stmts, resultExp)

  p2j-ast-exp:
    Fail(exp) -> result
    with
      (expStmts, expVal) := <try-p2j-ast-exp> exp
    ; stmts              := <concat> [
        expStmts
      , [ Throw(NewInstance(
            None()
          , []
          , Id("ExecException")
          , []
          , None()
          , [ InvokeQExp(expVal, None(), Id("toString"), [])]
          ))
        ]
        // Note: meaning of this AST: throw new ExecException([expVal].toString());
      ]
    ; resultExp          := <Snd> <try-p2j-ast-exp> UnitLit()
    ; result             := (stmts, resultExp)

rules // Literals

  p2j-ast-exp: UnitLit()        -> ([], Field(ExpressionName(Id("None")), Id("instance")))
  p2j-ast-exp: BoolLit(True())  -> ([], NewInstance(None(), [], Id("Boolean"), [], None(), [True()]))
  p2j-ast-exp: BoolLit(False()) -> ([], NewInstance(None(), [], Id("Boolean"), [], None(), [False()]))
  p2j-ast-exp: IntLit(i)        -> ([], NewInstance(None(), [], Id("Integer"), [], None(), [Deci(i)]))
  p2j-ast-exp: NullLit()        -> ([], Null())


  p2j-ast-exp:
    TupleLit(exps) -> result
    with
      <add-import> "mb.pie.util.Util"
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := InvokeQExp(ExpressionName(Id("Util")), None(), Id("tuple"), expsVals)
      //  Note: meaning of this AST: Util.tuple([expsVals])
    ; result                := (stmts, exp)

  p2j-ast-exp:
    ListLit(exps) -> result
    with
      <add-import> "java.util.Arrays"
    ; <add-import> "java.util.ArrayList"
    ; (expsStmts, expsVals) := <unzip> <map(try-p2j-ast-exp)> exps
    ; stmts                 := <concat> expsStmts
    ; exp                   := NewInstance(None(), [], Id("ArrayList"), [], Some(Diamond()), [
        InvokeQExp(ExpressionName(Id("Arrays")), None(), Id("asList"), expsVals)
      ])
    //  Note: meaning of this AST: new ArrayList<>(Arrays.asList([expsVals]))
    ; result                := (stmts, exp)

rules // Interpolated string literal

  p2j-ast-exp:
    StrLit([]) -> result
    with
      result := ([], StringLiteral($[""]))

  p2j-ast-exp:
    StrLit(parts@[first|rest]) -> result
    with
      (partsStmts, partsExps) := <unzip> <map(p2j-ast-strpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := <fold-left(p2j-ast-add-strings)> partsExps
    ; result                  := (stmts, exp)

  // Replace all escaped \$ with $. Note: "\\$" because the \ needs to be escaped in stratego.
  // todo: Check if simply replacing is fine, or if it is possible that it is actually a $,
  // e.g. "\\$foo" should evaluate to "\<valueOfFoo>"
  p2j-ast-strpart:
    Str(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-strpart:
    StrInterpRef(refExp) -> result
    with
      (stmts, expVal) := <try-p2j-ast-exp> refExp
    ; resultVal       := InvokeQExp(
        ExpressionName(Id("String"))
      , None()
      , Id("valueOf")
      , [ expVal ]
      )
    ; result          := (stmts, resultVal)


  p2j-ast-strpart:
    StrInterpExp(exp) -> result
    with
      (stmts, expVal) := <try-p2j-ast-exp> exp
    ; resultVal       := InvokeQExp(
        ExpressionName(Id("String"))
      , None()
      , Id("valueOf")
      , [ expVal ]
      )
    ; result          := (stmts, resultVal)

  p2j-ast-add-strings:
    (e1, e2) -> Add(e1, e2)

rules // Interpolated path literal

  p2j-ast-exp:
    e@PathLit(prefix, parts) -> result
    with
      <add-import> "mb.resource.fs.FSPath"
    ; (partsStmts, partsExps) := <unzip> <map(p2j-ast-pathpart)> parts
    ; stmts                   := <concat> partsStmts
    ; exp                     := NewInstance(None(), [], Id("FSPath"), [], None(), [
        <fold-left(p2j-ast-add-strings)> [StringLiteral($["[prefix]"]) | partsExps]
      ])
      // Note: meaning of this AST: new FSPath("[prefix][partsStr]")
    ; result                      := (stmts, exp)

  p2j-ast-pathpart:
    Path(chars) -> ([], StringLiteral($["[<string-replace(|"\\$", "$")> chars]"]))

  p2j-ast-pathpart:
    PathInterpRef(refExp) -> <try-p2j-ast-exp> refExp

  p2j-ast-pathpart:
    PathInterpExp(exp) -> <try-p2j-ast-exp> exp
