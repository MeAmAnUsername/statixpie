module statics/type

imports

  signatures/data-sig
  signatures/type-sig
  statics/base

signature
  constructors
    UnitType : TYPE
    BoolType : TYPE
    IntType : TYPE
    StrType : TYPE
    PathType : TYPE
    NullType : TYPE
    TopType : TYPE
    
    NullableType : TYPE -> TYPE
    ListType : TYPE -> TYPE
    EmptyListType : TYPE
    TupleType : list(TYPE) -> TYPE
    SupplierType : TYPE -> TYPE
    
    FuncType : list(TYPE) * TYPE -> TYPE
    DataType : string * scope -> TYPE

rules // operations on types

  /**
   * subtype(T1, T2)
   * Holds if type T1 is a non-strict subtype of type T2.
   * Fails with error if T1 is not a subtype of T2.
   * Will unify unbound variables if possible.
   */
  subtype : TYPE * TYPE
  subtypes maps subtype(list(*), list(*))
  subtype(NullType(), NullableType(_)).
  subtype(T, NullableType(T)).
  subtype(EmptyListType(), ListType(_)).
  subtype(T1, T2) :- T1 == T2.

  /**
   * isSubtype(T1, T2)
   * Returns TRUE() if type T1 is a non-strict subtype of type T2, FALSE() otherwise.
   * May fail on unbound variables.
   */
  isSubtype : TYPE * TYPE -> BOOLEAN
  isSubtype(NullType(), NullableType(_)) = TRUE().
  isSubtype(T, NullableType(T)) = TRUE().
  isSubtype(EmptyListType(), ListType(_)) = TRUE().
  isSubtype(T1, T2) = isSubtypeHelper(T1, T2).

  // this rule is here to prevent "overlapping rules" error
  // on isSubtype(T, NullableType(T))
  isSubtypeHelper : TYPE * TYPE -> BOOLEAN
  isSubtypeHelper(T, T) = TRUE().
  isSubtypeHelper(_, _) = FALSE().

  /**
   * Returns the first element in the list that is TRUE(), or the default otherwise.
   */
  firstTrueT : list((BOOLEAN * TYPE)) * TYPE -> TYPE
  firstTrueT([], T) = T.
  firstTrueT([(FALSE(), _)|rest], T) = firstTrueT(rest, T).
  firstTrueT([(TRUE(), T)|_], _) = T.

  makeNullable : TYPE -> TYPE
  makeNullable(NullType()) = NullType().
  makeNullable(T@NullableType(_)) = T.
  makeNullable(T) = NullableType(T).  

  lub : TYPE * TYPE -> TYPE
  listLub : list(TYPE) -> TYPE
  lub(NullType(), T) = makeNullable(T).
  lub(T, NullType()) = makeNullable(T).
  lub(EmptyListType(), ListType(T)) = ListType(T).
  lub(ListType(T), EmptyListType()) = ListType(T).
  lub(T1, T2) = firstTrueT([
    (isSubtype(T1, T2), T2),
    (isSubtype(T2, T1), T1)],
    TopType()).
  
  listLub([]) = TopType().
  listLub([T]) = T.
  listLub([T1|[T2|[]]]) = lub(T1, T2).
  listLub([T1|[T2|rest]]) = listLub([lub(T1, T2) | rest]).
  
  /**
   * Holds if the two types are comparable.
   * This disregards the possibilty for two incomparable but Nullable values to
   * both be null and the possibilty for two list types to both be empty lists.
   */
  comparable : TYPE * TYPE
  listComparable maps comparable(list(*), list(*))
  comparable(TupleType(T1s), TupleType(T2s)) :- listComparable(T1s, T2s).
  comparable(ListType(T1), ListType(T2)) :- comparable(T1, T2).
  comparable(SupplierType(T1), SupplierType(T2)) :- comparable(T1, T2).
  comparable(T1, T2) :- orB(isSubtype(T1, T2), isSubtype(T2, T1)) == TRUE().

rules

  typeOf : scope * Type -> TYPE
  typesOf maps typeOf(*, list(*)) = list(*)

  typeOf(_, BaseType2Type(UnitTy())) = UnitType().
  typeOf(_, BaseType2Type(BoolTy())) = BoolType().
  typeOf(_, BaseType2Type(IntTy()))  = IntType().
  typeOf(_, BaseType2Type(StrTy()))  = StrType().
  typeOf(_, BaseType2Type(PathTy())) = PathType().
  typeOf(s, BaseType2Type(DataTy2BaseType(data_ty))) = typeOfDataTy(s, data_ty).
  typeOf(s, BaseType2Type(TupleTy(tys))) = TupleType(typesOf(s, tys)).
  typeOf(s, BaseType2Type(ListTy(ty))) = ListType(typeOf(s, ty)).
  // todo: SupplierTy
  typeOf(s, TypeMod2Type(NullableTy(ty))) = NullableType(typeOf(s, BaseType2Type(ty))).

  typeOfDataTy : scope * DataTy -> TYPE
  // todo
