module statics/data

imports

  signatures/data-sig
  statics/base
  statics/type
  statics/util
  statics/func_def

rules

  dataDefOk : scope * DataDef
  dataDefOk(s, DataDef(DataDefMods(mods), name, super, impl)) :- {s_data}
    dataDefModsOk(mods),
    new s_data,
    s_data -ROOT-> getRoot(s),
    declareData(s, name, s_data),
    @name.mods := mods,
    superOk(s, s_data, super, name),
    dataImplOk(s, s_data, impl).

  dataDefModsOk : list(DataDefMod)
  dataDefModsOk([]).
  dataDefModsOk([mod|mods1]) :- {mods2}
    dataDefModsOk_1(mods1, mod) == mods2,
    dataDefModsOk(mods2).
    
    // checks that mods list does not contain a duplicate modifier
    // returns list with duplicates removed
    dataDefModsOk_1 : list(DataDefMod) * DataDefMod -> list(DataDefMod)
    dataDefModsOk_1([], _) = [].
    dataDefModsOk_1([mod|mods], mod) = mods_out :-
      dataDefModsOk_1(mods, mod) == mods_out,
      false | error $[Duplicate modifier [mod]] @mod.
    dataDefModsOk_1([mod1|mods], mod2) = [mod1|mods_out] :-
      dataDefModsOk_1(mods, mod2) == mods_out.

  superOk : scope * scope * SuperType * string
  superOk(s, s_data, NoSuperType(), name).
  superOk(s, s_data, SuperType(data_ty@DataTy(_, super_name)), name) :- {s_super}
    typeOfDataTy(s, data_ty) == DataType(s_super),
    s_data -INHERIT-> s_super,
    inherits(s_super, s_data) == FALSE() | error $[Cannot (indirectly) inherit from self. [super_name] is already an (indirect) subtype of [name]] @super_name.
    // todo: check that all functions in s_data are subtypes of functions in s_super
  
  dataImplOk : scope * scope * DataImpl
  dataImplOk(s, s_data, JavaDataImpl(java_name, members)) :-
    javaDataMembersOk(s, s_data, members).
  
  javaDataMemberOk : scope * scope * JavaDataMemb
  javaDataMembersOk maps javaDataMemberOk(*, *, list(*))
  javaDataMemberOk(s, s_data, JavaFuncDef(func_head)) :- {name ty}
    typeOfFuncHead(s, func_head) == (_, name, ty),
    declareFunc(s_data, name, ty).