module statics/module

imports

  statics/base
  statics/util

signature
  sorts
    ModuleTree

  constructors
    ModuleTreeRoot : list(ModuleTree) -> ModuleTree
    ModuleTreeNode : MODID * list(scope) * list(ModuleTree) -> ModuleTree

rules

  /**
   * declareWipModule(s_project, s_mod, Module(moduleList, name))
   * Declare a work in progress module [s_mod] named [name] in the relation
   * mod_wip. [name] is declared recursively nested in the modules of
   * [moduleList] starting in the root scope [s_project].
   * The module is work in progress because there can be multiple such
   * recursively nested modules, possibly with duplicate names.
   * The modules are deduplicated in statics/project.stx!projectOk.
   */
  declareWipModule : scope * scope * Module
  declareWipModule(s_project, s_mod, module@Module(_, name)) :-
    !mod_wip[name, (s_mod, module)] in s_project.

  /**
   * declareDeduplicatedModules(s_root)
   * Gets all declared work in progress modules (see
   * statics/base!declareWipModule), converts them to a module tree (without
   * duplicates) and then declares all the modules.
   */
  declareDeduplicatedModules : scope
  declareDeduplicatedModules(s) :- {occs tree}
    query mod_wip filter e in s |-> occs,
    addAllToModuleTree(ModuleTreeRoot([]), occs) == tree,
    declareModulesFromTree(s, tree).

  /**
   * addAllToModuleTree(root_in, wip_modules) -> root_out
   * Add all wip modules [wip_modules] to module tree [root_in].
   * root_in is required to be a ModuleTreeRoot
   * All modules are deduplicated and added recursively.
   */
  addAllToModuleTree : ModuleTree * list((path * (string * (scope * Module)))) -> ModuleTree
  addAllToModuleTree(node@ModuleTreeNode(_, _, _), []) = node :-
    false | error $[BUG: called addAllToModuleTree with a non-root node].
  addAllToModuleTree(root@ModuleTreeRoot(_), []) = root.
  addAllToModuleTree(root_1@ModuleTreeRoot(_), [occ|occs]) = root_3 :- {root_2}
    addToModuleTree(root_1, occ) == root_2,
    addAllToModuleTree(root_2, occs) == root_3.

  /**
   * addToModuleTree(root_in, wip_module_occurrence) -> root_out
   * Add module from [wip_module_occurrence] to module tree [root_in].
   * root_in is required to be a ModuleTreeRoot
   * The module is added recursively and deduplicated as necessary.
   */
  addToModuleTree : ModuleTree * (path * (string * (scope * Module))) -> ModuleTree
  addToModuleTree(node@ModuleTreeNode(_, _, _), _) = node :-
    false | error $[BUG: called addToModuleTree with a non-root node].
  addToModuleTree(ModuleTreeRoot(modules), (_, (_, (s_mod, module)))) =
    ModuleTreeRoot(addToModuleTree_1(modules, moduleToList(module), s_mod)).

    addToModuleTree_1 : list(ModuleTree) * list(MODID) * scope -> list(ModuleTree)
    addToModuleTree_1(_, [], s_mod) = [] :- false | error "BUG: called addToModuleTree_1 with empty module name list".
    addToModuleTree_1([], [name], s_mod) =
      [ModuleTreeNode(name, [s_mod], [])].
    addToModuleTree_1([ModuleTreeNode(name, scopes, sub_modules)|modules], [name_node@name], s_mod) =
      [ModuleTreeNode(name_node, [s_mod|scopes], sub_modules)|modules].
    addToModuleTree_1([module@ModuleTreeNode(name', _, _)|modules], [name], s_mod) =
      [module|addToModuleTree_1(modules, [name], s_mod)] :- name' != name.
    addToModuleTree_1([], [name|names], s_mod) =
      [ModuleTreeNode(name, [], addToModuleTree_1([], names, s_mod))].
    addToModuleTree_1([ModuleTreeNode(name , scopes, sub_modules)|modules], [name|names], s_mod) =
      [ModuleTreeNode(name, scopes, addToModuleTree_1(sub_modules, names, s_mod))|modules].
    addToModuleTree_1([module@ModuleTreeNode(name', _, _)|modules], names@[name|_], s_mod) =
      [module|addToModuleTree_1(modules, names, s_mod)] :- name' != name.

  /**
   * declareModulesFromTree(s, tree)
   * Declares all modules in the tree with a new scope and adds a pointer to
   * the file scopes where applicible (see statics/base!instantiateModule).
   */
  declareModulesFromTree : scope * ModuleTree
  declareModulesFromTrees maps declareModulesFromTree(*, list(*))
  declareModulesFromTree(s, ModuleTreeRoot(sub_modules)) :-
    declareModulesFromTrees(s, sub_modules).
  declareModulesFromTree(s, ModuleTreeNode(name, scopes, sub_modules)) :- {s_mod_tree}
    new s_mod_tree,
    s_mod_tree -ROOT-> getRoot(s),
    declareModule(s, name, s_mod_tree),
    setContext(s_mod_tree, "module_name_simple", ContextName(name)),
    instantiateModules(s_mod_tree, scopes),
    declareModulesFromTrees(s_mod_tree, sub_modules),
    declareModulesFromTree_1(scopes).

    // give duplicate name error if list has more than one element
    declareModulesFromTree_1 : list(scope)
    declareModulesFromTree_1([]).
    declareModulesFromTree_1([_]).
    declareModulesFromTree_1(scopes@[_, _|_]) :-
      declareModulesFromTree_2s(scopes, scopes).

    // give an error on name of s_mod and set references to all other names from scopes in list
    declareModulesFromTree_2 : scope * list(scope)
    declareModulesFromTree_2s maps declareModulesFromTree_2(list(*), *)
    declareModulesFromTree_2(s_mod, scopes) :- {module module_pp name}
      getContext(s_mod, "module_name_qualified") == ContextModule(module) | error $[BUG: cannot get qualified module name from [s_mod]],
      moduleToList(module) == module_pp,
      false | error $[Duplicate module [module_pp]. Ctrl/Cmd + click on [name] to go to duplicate definition.] @module,
      getContext(s_mod, "module_name_simple") == ContextName(name) | error $[BUG: cannot get simple module name from [s_mod]],
      declareModulesFromTree_3s(declareModulesFromTree_4(scopes, s_mod), name).

    // set a reference from name to s_cur
    declareModulesFromTree_3 : scope * string
    declareModulesFromTree_3s maps declareModulesFromTree_3(list(*), *)
    declareModulesFromTree_3(s_cur, ref_name) :- {cur_name}
      getContext(s_cur, "module_name_simple") == ContextName(cur_name) | error $[BUG: cannot get module name from [s_cur]],
      @ref_name.ref := cur_name.

    // filter scope from list of scopes
    // assumes that scope only occurs once.
    declareModulesFromTree_4 : list(scope) * scope -> list(scope)
    declareModulesFromTree_4([], _) = [].
    declareModulesFromTree_4([s_mod|rest], s_mod) = rest.
    declareModulesFromTree_4([s    |rest], s_mod) = [s|declareModulesFromTree_4(rest, s_mod)] :-
      s != s_mod.

  /**
   * declareModule(s, name, s_mod)
   * Declare a module [s_mod] named [name] in scope [s].
   */
  declareModule : scope * MODID * scope
  declareModule(s, name, s_mod) :-
    !mod[name, s_mod] in s,
    query mod filter e and {name' :- name' == name} in s |-> [_]
      | error $[BUG: duplicate definitions for module [name] in [s]].

  /**
   * instantiateModule(s_mod_tree, s_mod_file)
   * Instantiate module [s_mod_file] by adding a MOD_INSTANCE edge to
   * [s_mod_tree].
   */
  instantiateModule : scope * scope
  instantiateModules maps instantiateModule(*, list(*))
  instantiateModule(s_mod_tree, s_mod_file) :-
    s_mod_tree -MOD_INSTANCE-> s_mod_file.

   /**
    * getModuleName(s_mod) -> name
    * Get the simple name of a module from its scope.
    * Works with both module tree scopes as module file scopes.
    */ 
  getModuleName : scope -> MODID
  getModuleName(s_mod) = name :-
    getContext(s_mod, "module_name_simple") == ContextName(name)
      | error $[BUG: cannot get module name in [s_mod]].

  /**
   * resolveModuleListToFile(s, moduleList) = s_tree
   * Resolve the modules from the ModuleList [moduleList] and return the module
   * file scope [s_file] of the last module in the list.
   * Also sets references on the names in the moduleList to files, if
   * such files exist. (example: given foo:bar:baz, it points foo to a file foo
   * if it exists and bar to a file foo:bar if it exists)
   */
  resolveModuleListToFile : scope * ModuleList -> scope
  resolveModuleListToFile(s, NoModuleList()) = s.
  resolveModuleListToFile(s, moduleList@ModuleList(mods)) = s_file :- {s_mod occs name name_node}
    resolveModuleList(s, moduleList) == s_mod,
    query () filter MOD_INSTANCE in s_mod |-> occs,
    getModuleName(s_mod) == name,
    resolveModuleListToFile_1(mods) == name_node,
    occs == [(_, s_file)|_] | error $[Submodule [name] is not instantiated] @name_node,
    try { occs != [_, _ | _] } | error $[Duplicate module [name]] @name_node.

    // Returns the last name in the ModuleList.
    resolveModuleListToFile_1 : list(MODID) -> MODID
    resolveModuleListToFile_1([]) = "<<ERROR>>" :- false | error $[BUG: called resolveModuleListToFile_1 with empty list].
    resolveModuleListToFile_1([name]) = name.
    resolveModuleListToFile_1([_|mods]) = resolveModuleListToFile_1(mods).

  /**
   * resolveModuleList(s, moduleList) = s_mod_tree
   * Resolve the modules from the ModuleList [moduleList] and return the module
   * tree scope [s_mod_tree] of the last module in the list.
   * Also sets references on the names in the moduleList to files, if
   * such files exist. (example: given foo:bar:baz, it points foo to a file foo
   * if it exists and bar to a file foo:bar if it exists)
   */
  resolveModuleList : scope * ModuleList -> scope
  resolveModuleList(s, NoModuleList()) = s.
  resolveModuleList(s, ModuleList(mods)) = s_mod :- {s_root}
    getRoot(s) == s_root,
    resolveModuleList_1(s_root, mods) == s_mod.
    
    resolveModuleList_1 : scope * list(MODID) -> scope
    resolveModuleList_1(s, []) = s.
    resolveModuleList_1(s, [name|names]) = resolveModuleList_1(s_next, names) :- {occs instance_occs}
      query mod filter e and {name' :- name' == name} in s |-> occs,
      occs == [(_, (_, s_next))] | error $[Cannot resolve [name]] @name,
      try { occs != [_|[_|_]] } | error $[BUG: submodule [name] resolves to multiple modules, occs: [occs]] @name,
      query () filter MOD_INSTANCE in s_next |-> instance_occs,
      resolveModuleList_2s(instance_occs, name).

    // adds references to files if file exists
    resolveModuleList_2 : (path * scope) * MODID
    resolveModuleList_2s maps resolveModuleList_2(list(*), *)
    resolveModuleList_2((_, s), ref_name) :- {orig_name}
      getContext(s, "module_name_simple") == ContextName(orig_name),
      @ref_name.ref := orig_name.
