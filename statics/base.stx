module statics/base

imports

  signatures/lex/literal-sig
  signatures/statixpie-sig
  statics/util
  statics/type

signature
  sorts
    TYPE // A semantic type (as opposed to the lexical, non-all caps Type)
    ValKind // The kind of a value. Used by code generation.
    BOOLEAN // For logic in this statix spec.
    ModuleTree // For constructing the tree of modules
    CONTEXT // context values that are saved in the scope graph

  relations
    mod_wip : MODID -> (scope * Module)
    mod : MODID -> scope
    val : VALID -> TYPE
    func : FUNCID -> TYPE
    data : TYPEID -> scope
    context : string -> CONTEXT

  constructors
    InputValKind : ValKind
    LocalValKind : ValKind
    TRUE : BOOLEAN
    FALSE : BOOLEAN
    ModuleTreeRoot : list(ModuleTree) -> ModuleTree
    ModuleTreeNode : MODID * list(scope) * list(ModuleTree) -> ModuleTree
    ContextType : TYPE -> CONTEXT
    ContextName : string -> CONTEXT

signature
  name-resolution
    labels
      P // Scopes within functions; function scope to file scope.
      INHERIT // Between data scopes
      ROOT // file scope to root scope. Root scope is the project scope.
      MOD_INSTANCE // from a module tree scope to a file scope

rules // Logic functions

  /**
   * Logical and. Called andB because `and` is apparently a keyword.
   */
  andB : BOOLEAN * BOOLEAN -> BOOLEAN
  andB(FALSE(), _) = FALSE().
  andB(_, FALSE()) = FALSE().
  andB(TRUE(), TRUE()) = TRUE().
  andB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for andB([a], [b]).].
  
  /**
   * return TRUE() if all values in the list are TRUE().
   */
  allTrue : list(BOOLEAN) -> BOOLEAN
  allTrue([]) = TRUE().
  allTrue([FALSE()|_]) = FALSE().
  allTrue([TRUE()|rest]) = allTrue(rest).

  orB : BOOLEAN * BOOLEAN -> BOOLEAN
  orB(TRUE(), _) = TRUE().
  orB(_, TRUE()) = TRUE().
  orB(FALSE(), FALSE()) = FALSE().
  orB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for orB([a], [b]).].
  
  notB : BOOLEAN -> BOOLEAN
  notB(TRUE()) = FALSE().
  notB(FALSE()) = TRUE().

rules // Declararing and resolving

  /**
   * getRoot(s)
   * Get the root scope. The root scope is the scope passed to
   * statics/project!projectOk.
   * All scopes have a path to the root scope and all paths to the root scope
   * end with a ROOT edge.
   */
  getRoot : scope -> scope
  getRoot(s) = s_root :- {occs}
    query () filter P* ROOT in s |-> occs,
    occs == [(_, s_root)] | error $[BUG: cannot resolve root scope from [s]. occs: [occs]].

  /**
   * declareWipModule(s_project, s_mod, Module(moduleList, name))
   * Declare a work in progress module [s_mod] named [name] in the relation
   * mod_wip. [name] is declared recursively nested in the modules of
   * [moduleList] starting in the root scope [s_project].
   * The module is work in progress because there can be multiple such
   * recursively nested modules, possibly with duplicate names.
   * The modules are deduplicated in statics/project.stx!projectOk.
   */
  declareWipModule : scope * scope * Module
  declareWipModule(s_project, s_mod, module@Module(_, name)) :-
    !mod_wip[name, (s_mod, module)] in s_project.

  /**
   * declareDeduplicatedModules(s_root)
   * Gets all declared work in progress modules (see
   * statics/base!declareWipModule), converts them to a module tree (without
   * duplicates) and then declares all the modules.
   */
  declareDeduplicatedModules : scope
  declareDeduplicatedModules(s) :- {occs tree}
    query mod_wip filter e in s |-> occs,
    addAllToModuleTree(ModuleTreeRoot([]), occs) == tree,
    declareModulesFromTree(s, tree).

  /**
   * addAllToModuleTree(root_in, wip_modules) -> root_out
   * Add all wip modules [wip_modules] to module tree [root_in].
   * root_in is required to be a ModuleTreeRoot
   * All modules are deduplicated and added recursively.
   */
  addAllToModuleTree : ModuleTree * list((path * (string * (scope * Module)))) -> ModuleTree
  addAllToModuleTree(node@ModuleTreeNode(_, _, _), []) = node :-
    false | error $[BUG: called addAllToModuleTree with a non-root node].
  addAllToModuleTree(root@ModuleTreeRoot(_), []) = root.
  addAllToModuleTree(root_1@ModuleTreeRoot(_), [occ|occs]) = root_3 :- {root_2}
    addToModuleTree(root_1, occ) == root_2,
    addAllToModuleTree(root_2, occs) == root_3.

  /**
   * addToModuleTree(root_in, wip_module_occurrence) -> root_out
   * Add module from [wip_module_occurrence] to module tree [root_in].
   * root_in is required to be a ModuleTreeRoot
   * The module is added recursively and deduplicated as necessary.
   */
  addToModuleTree : ModuleTree * (path * (string * (scope * Module))) -> ModuleTree
  addToModuleTree(node@ModuleTreeNode(_, _, _), _) = node :-
    false | error $[BUG: called addToModuleTree with a non-root node].
  addToModuleTree(ModuleTreeRoot(modules), (_, (_, (s_mod, module)))) =
    ModuleTreeRoot(addToModuleTree_1(modules, moduleToList(module), s_mod)).

    addToModuleTree_1 : list(ModuleTree) * list(MODID) * scope -> list(ModuleTree)
    addToModuleTree_1(_, [], s_mod) = [] :- false | error "BUG: called addToModuleTree_1 with empty module name list".
    addToModuleTree_1([], [name], s_mod) =
      [ModuleTreeNode(name, [s_mod], [])].
    addToModuleTree_1([ModuleTreeNode(name, scopes, sub_modules)|modules], [name], s_mod) =
      [ModuleTreeNode(name, [s_mod|scopes], sub_modules)|modules].
    addToModuleTree_1([module@ModuleTreeNode(name', _, _)|modules], [name], s_mod) =
      [module|addToModuleTree_1(modules, [name], s_mod)] :- name' != name.
    addToModuleTree_1([], [name|names], s_mod) =
      [ModuleTreeNode(name, [], addToModuleTree_1([], names, s_mod))].
    addToModuleTree_1([ModuleTreeNode(name , scopes, sub_modules)|modules], [name|names], s_mod) =
      [ModuleTreeNode(name, scopes, addToModuleTree_1(sub_modules, names, s_mod))|modules].
    addToModuleTree_1([module@ModuleTreeNode(name', _, _)|modules], names@[name|_], s_mod) =
      [module|addToModuleTree_1(modules, names, s_mod)] :- name' != name.

  declareModulesFromTree : scope * ModuleTree
  declareModulesFromTrees maps declareModulesFromTree(*, list(*))
  declareModulesFromTree(s, ModuleTreeRoot(sub_modules)) :-
    declareModulesFromTrees(s, sub_modules).
  declareModulesFromTree(s, ModuleTreeNode(name, scopes, sub_modules)) :- {s_mod_tree}
    new s_mod_tree,
    s_mod_tree -ROOT-> getRoot(s),
    declareModule(s, name, s_mod_tree),
    instantiateModules(s_mod_tree, scopes),
    declareModulesFromTrees(s_mod_tree, sub_modules),
    try { scopes != [_|[_|_]] } | error $[Duplicate module] @name. // todo: error on all names.

  declareModule : scope * MODID * scope
  declareModule(s, name, s_mod) :-
    !mod[name, s_mod] in s,
    query mod filter e in s |-> [_] | error $[BUG: duplicate definitions for module [name] in [s]].

  instantiateModule : scope * scope
  instantiateModules maps instantiateModule(*, list(*))
  instantiateModule(s_mod_tree, s_mod_file) :-
    s_mod_tree -MOD_INSTANCE-> s_mod_file.


  resolveModuleList : scope * ModuleList -> scope
  resolveModuleList(s, NoModuleList()) = s.
  resolveModuleList(s, ModuleList(mods)) = s_mod :- {s_root}
    getRoot(s) == s_root,
    resolveModuleList_1(s_root, mods) == s_mod.
    
    resolveModuleList_1 : scope * list(MODID) -> scope
    resolveModuleList_1(s, []) = s.
    resolveModuleList_1(s, [name|names]) = resolveModuleList_1(s_next, names) :- {occs instance_occs}
      query mod filter e and {name' :- name' == name} in s |-> occs,
      occs == [(_, (_, s_next))] | error $[Cannot resolve [name]] @name,
      try { occs != [_|[_|_]] } | error $[BUG: submodule [name] resolves to multiple modules, occs: [occs]] @name,
      query () filter MOD_INSTANCE in s_next |-> instance_occs,
      resolveModuleList_2s(instance_occs, name).

    // adds references to files if applicable
    resolveModuleList_2 : (path * scope) * MODID
    resolveModuleList_2s maps resolveModuleList_2(list(*), *)
    resolveModuleList_2((_, s), ref_name) :- {orig_name}
      getContext(s, "module_name") == ContextName(orig_name),
      @ref_name.ref := orig_name.


  /**
   * Declare a value [name] with type [TYPE] and ValKind [kind] in scope [s]
   */
  declareVal : scope * string * TYPE * ValKind
  declareVal(s, name, type, kind) :-
    {occs} // todo: remove
//    try { false } | note $[Declare val [name] in [s]: occs=[occs]], // todo: remove
    !val[name, type] in s,
    @name.kind := kind,
    occs@resolveVal(s, name) == [_]
      | error $[Duplicate definition of value [name]],
    @name.type := type.

  /**
   * Resolve a value [name] in scope [s]
   */
  resolveVal : scope * string -> list((path * (string * TYPE)))
  resolveVal(s, name) = occs :-
//    try { false } | note $[Resolve val [name] in [s]: occs=[occs]], // todo: remove
    query val
      filter P*
         and { name' :- name' == name }
         min $ < P
         and false 
          in s |-> occs.

  resolveUniqueVal : scope * string -> TYPE
  resolveUniqueVal(s, name) = ty :- {occs name'}
    resolveVal(s, name) == occs,
    occs == [(_, (name', ty))],
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Cannot resolve [name]] @name.


  /**
   * Declare a function [name] with type [TYPE] in scope [s]
   */
  declareFunc : scope * string * TYPE
  declareFunc(s, name, type) :-
    {occs} // todo: remove
//    try { false } | note $[Declare func [name] in [s]: occs=[occs]], // todo: remove
    !func[name, type] in s,
    occs@resolveFunc(s, name) == [_]
      | error $[Duplicate definition of function [name]],
    @name.type := type.

  /**
   * Resolve a function [name] in scope [s]
   */
  resolveFunc : scope * string -> list((path * (string * TYPE)))
  resolveFunc(s, name) = occs :-
    query func
      filter P*|INHERIT*
         and { name' :- name' == name }
         min $ < P, $ < INHERIT
         and true // todo: set to false to implement overloading between classes
          in s |-> occs.

  /**
   * resolve a function [name] to a unique declaration in scope [s]
   */
  resolveUniqueFunc : scope * string -> TYPE
  resolveUniqueFunc(s, name) = ty :- {occs name'}
    resolveFunc(s, name) == occs,
    occs == [(_, (name', ty))],
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve function [name]] @name.


  /**
   * Declare a datatype [name] with scope [s_data] in scope [s]
   */
  declareData : scope * string * scope
  declareData(s, name, s_data) :-
    {occs} // todo: remove
//    try { false } | note $[Declare func [name] in [s]: occs=[occs]], // todo: remove
    !data[name, s_data] in s,
    occs@resolveData(s, name) == [_]
      | error $[Duplicate definition of Datatype [name]],
    @name.type := DataType(s_data).

  /**
   * Resolve data [name] in scope [s] to a list of data scopes
   */
  resolveData : scope * string -> list((path * (string * scope)))
  resolveData(s, name) = occs :-
    query data
      filter MOD_INSTANCE? P* // todo: also add `MOD_INSTANCE?` to other queries
         and { name' :- name' == name }
         min $ < P
         and false
          in s |-> occs.

  /**
   * resolve data [name] to a unique data scope [s_data] in scope [s]
   */
  resolveUniqueData : scope * string -> scope
  resolveUniqueData(s, name) = s_data :- {occs name'}
    resolveData(s, name) == occs,
    occs == [(_, (name', s_data))],
    @name.ref := name',
    @name.type := DataType(s_data),
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve data [name]] @name.

  /**
   * setContext(s, name, context)
   * Set a context value [context] named [name] in scope [s].
   */
  setContext : scope * string * CONTEXT
  setContext(s, name, context) :-
    !context[name, context] in s,
    getContext(s, name) == context | error $[Context value [name] is already set in [s]].

  /**
   * getContext(s, name) -> context
   * Get a context value [context] named [name] from scope [s].
   */
  getContext : scope * string -> CONTEXT
  getContext(s, name) = context :- {occs}
    query context
      filter P*
         and { name' :- name' == name }
         min $ < P
         and true
          in s |-> occs,
    occs == [(_, (_, context))],
    try { occs != [] } | error $[cannot get context value [name] in [s]].
