module statics/base

imports

  signatures/lex/literal-sig
  signatures/statixpie-sig
  statics/util
  statics/type

signature
  sorts
    TYPE // A semantic type (as opposed to the lexical, non-all caps Type)
    ValKind // The kind of a value. Used by code generation.
    BOOLEAN // For logic in this statix spec.
    CONTEXT // context values that are saved in the scope graph

  constructors
    InputValKind : ValKind
    LocalValKind : ValKind
    TRUE : BOOLEAN
    FALSE : BOOLEAN
    ContextType : TYPE -> CONTEXT
    ContextName : string -> CONTEXT
    ContextModule : Module -> CONTEXT

  relations
    mod_wip : MODID -> (scope * Module) // todo: remove name (MODID)
    mod : MODID -> scope
    val : VALID -> TYPE
    func : FUNCID -> TYPE
    data : TYPEID -> scope
    context : string -> CONTEXT

signature
  name-resolution
    labels
      INHERIT // Between data scopes
      P // Scopes within functions
      FILE // function scope to file scope; from a module tree scope to a file scope
      ROOT // file scope to root scope. Root scope is the project scope.
      MODULE_TREE_ROOT // points to a module tree root. Starts in root scope for
                       // module structure or file scope for pseudo modules from imports

rules // Logic functions

  /**
   * Logical and. Called andB because `and` is apparently a keyword.
   */
  andB : BOOLEAN * BOOLEAN -> BOOLEAN
  andB(FALSE(), _) = FALSE().
  andB(_, FALSE()) = FALSE().
  andB(TRUE(), TRUE()) = TRUE().
  andB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for andB([a], [b]).].
  
  /**
   * return TRUE() if all values in the list are TRUE().
   */
  allTrue : list(BOOLEAN) -> BOOLEAN
  allTrue([]) = TRUE().
  allTrue([FALSE()|_]) = FALSE().
  allTrue([TRUE()|rest]) = allTrue(rest).

  orB : BOOLEAN * BOOLEAN -> BOOLEAN
  orB(TRUE(), _) = TRUE().
  orB(_, TRUE()) = TRUE().
  orB(FALSE(), FALSE()) = FALSE().
  orB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for orB([a], [b]).].
  
  notB : BOOLEAN -> BOOLEAN
  notB(TRUE()) = FALSE().
  notB(FALSE()) = TRUE().

rules // Declararing and resolving

  // For declaring and resolving modules in relation `mod` and `mod_wip`, see
  // statics/module!declareModule and statics/module!resolveModuleList

  /**
   * Declare a value [name] with type [TYPE] and ValKind [kind] in scope [s],
   * set the type on the value name.
   */
  declareVal : scope * string * TYPE * ValKind
  declareVal(s, name, type, kind) :-
    declareValWithoutSettingType(s, name, type, kind),
    @name.type := type.

  /**
   * Declare a value [name] with type [TYPE] and ValKind [kind] in scope [s],
   * do not set the type on the value name.
   */
  declareValWithoutSettingType : scope * string * TYPE * ValKind
  declareValWithoutSettingType(s, name, type, kind) :-
    {occs} // todo: remove
//    try { false } | note $[Declare val [name] in [s]: occs=[occs]], // todo: remove
    !val[name, type] in s,
    @name.kind := kind,
    occs@resolveVal(s, name) == [_]
      | error $[Duplicate definition of value [name]].

  /**
   * Resolve a value [name] in scope [s]
   */
  resolveVal : scope * string -> list((path * (string * TYPE)))
  resolveVal(s, name) = occs :-
//    try { false } | note $[Resolve val [name] in [s]: occs=[occs]], // todo: remove
    query val
      filter P*
         and { name' :- name' == name }
         min and false
          in s |-> occs.

  resolveUniqueVal : scope * string -> TYPE
  resolveUniqueVal(s, name) = ty :- {occs name'}
    resolveVal(s, name) == occs,
    occs == [(_, (name', ty))],
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Cannot resolve [name]] @name.


  /**
   * Declare a function [name] with type [TYPE] in scope [s], set the type on
   * the function name.
   */
  declareFunc : scope * string * TYPE
  declareFunc(s, name, type) :-
    declareFuncWithoutSettingType(s, name, type),
    @name.type := type.

  /**
   * Declare a function [name] with type [TYPE] in scope [s], do not set a type
   * on the function name.
   */
  declareFuncWithoutSettingType : scope * string * TYPE
  declareFuncWithoutSettingType(s, name, type) :-
    {occs} // todo: remove
//    try { false } | note $[Declare func [name] in [s]: occs=[occs]], // todo: remove
    !func[name, type] in s,
    occs@resolveFunc(s, name) == [_] | error $[Duplicate definition of function [name]].
  

  /**
   * Resolve a function [name] in scope [s]
   */
  resolveFunc : scope * string -> list((path * (string * TYPE)))
  resolveFunc(s, name) = occs :-
    query func
      filter (P* FILE?)|INHERIT*
         and { name' :- name' == name }
         min $ < FILE, $ < INHERIT
         and true
          in s |-> occs.

  /**
   * resolve a function [name] to a unique declaration in scope [s]
   */
  resolveUniqueFunc : scope * string -> TYPE
  resolveUniqueFunc(s, name) = ty :- {occs name'}
    resolveFunc(s, name) == occs,
    occs == [(_, (name', ty))],
    // todo: allow overloading (multiple occurences, find best match by input types)
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve function [name]] @name.


  /**
   * Declare a datatype [name] with scope [s_data] in scope [s], set the type
   * on the data name.
   */
  declareData : scope * TYPEID * scope
  declareData(s, name, s_data) :-
    declareDataWithoutSettingType(s, name, s_data),
    @name.type := DataType(s_data).

  /**
   * Declare a datatype [name] with scope [s_data] in scope [s], do not set the
   * type on the data name.
   */
  declareDataWithoutSettingType : scope * TYPEID * scope
  declareDataWithoutSettingType(s, name, s_data) :-
    {occs} // todo: remove
//    try { false } | note $[Declare data type [name] in [s]: occs=[occs]], // todo: remove
    !data[name, s_data] in s,
    occs@resolveData(s, name) == [_]
      | error $[Duplicate definition of Datatype [name]].

  /**
   * Resolve data [name] in scope [s] to a list of data scopes
   */
  resolveData : scope * string -> list((path * (string * scope)))
  resolveData(s, name) = occs :-
    query data
      filter P* FILE?
         and { name' :- name' == name }
         min $ < FILE
         and true
          in s |-> occs.

  /**
   * resolve data [name] to a unique data scope [s_data] in scope [s]
   */
  resolveUniqueData : scope * string -> scope
  resolveUniqueData(s, name) = s_data :- {occs name'}
    resolveData(s, name) == occs,
    occs == [(_, (name', s_data))],
    @name.ref := name',
    @name.type := DataType(s_data),
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve data [name]] @name.

  /**
   * setContext(s, name, context)
   * Set a context value [context] named [name] in scope [s].
   */
  setContext : scope * string * CONTEXT
  setContext(s, name, context) :-
    !context[name, context] in s,
    getContext(s, name) == context | error $[Context value [name] is already set in [s]].

  /**
   * getContext(s, name) -> context
   * Get a context value [context] named [name] from scope [s].
   */
  getContext : scope * string -> CONTEXT
  getContext(s, name) = context :- {occs}
    query context
      filter P* FILE?
         and { name' :- name' == name }
         min $ < P, $ < FILE
         and true
          in s |-> occs,
    occs == [(_, (_, context))],
    try { occs != [] } | error $[cannot get context value [name] in [s]].
