module statics/base

imports

  signatures/lex/literal-sig
  statics/type

signature
  sorts
    TYPE // A semantic type (as opposed to the lexical, non-all caps Type)
    ValKind // The kind of a value. Used by code generation.
    BOOLEAN // For logic in this statix spec.

  relations
    val : VALID -> TYPE
    func : FUNCID -> TYPE
    data : TYPEID -> scope
    context : string -> TYPE

  constructors
    InputValKind : ValKind
    LocalValKind : ValKind
    TRUE : BOOLEAN
    FALSE : BOOLEAN

signature
  name-resolution
    labels P INHERIT

rules // Logic functions

  /**
   * Logical and. Called andB because `and` is apparently a keyword.
   */
  andB : BOOLEAN * BOOLEAN -> BOOLEAN
  andB(FALSE(), _) = FALSE().
  andB(_, FALSE()) = FALSE().
  andB(TRUE(), TRUE()) = TRUE().
  andB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for andB([a], [b]).].
  
  /**
   * return TRUE() if all values in the list are TRUE().
   */
  allTrue : list(BOOLEAN) -> BOOLEAN
  allTrue([]) = TRUE().
  allTrue([FALSE()|_]) = FALSE().
  allTrue([TRUE()|rest]) = allTrue(rest).

  orB : BOOLEAN * BOOLEAN -> BOOLEAN
  orB(TRUE(), _) = TRUE().
  orB(_, TRUE()) = TRUE().
  orB(FALSE(), FALSE()) = FALSE().
  orB(a, b) = FALSE() :- false | error $[Bug in Statix spec: no matching rule for orB([a], [b]).].
  
  notB : BOOLEAN -> BOOLEAN
  notB(TRUE()) = FALSE().
  notB(FALSE()) = TRUE().

rules // Declararing and resolving

  /**
   * Declare a value [name] with type [TYPE] and ValKind [kind] in scope [s]
   */
  declareVal : scope * string * TYPE * ValKind
  declareVal(s, name, type, kind) :-
    {occs} // todo: remove
//    try { false } | note $[Declare val [name] in [s]: occs=[occs]], // todo: remove
    !val[name, type] in s,
    @name.kind := kind,
    occs@resolveVal(s, name) == [_]
      | error $[Duplicate definition of value [name]],
    @name.type := type.

  /**
   * Resolve a value [name] in scope [s]
   */
  resolveVal : scope * string -> list((path * (string * TYPE)))
  resolveVal(s, name) = occs :-
//    try { false } | note $[Resolve val [name] in [s]: occs=[occs]], // todo: remove
    query val
      filter P*
         and { name' :- name' == name }
         min $ < P
         and false 
          in s |-> occs.

  resolveUniqueVal : scope * string -> TYPE
  resolveUniqueVal(s, name) = ty :- {occs name'}
    resolveVal(s, name) == occs,
    occs == [(_, (name', ty))],
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Cannot resolve [name]] @name.


  /**
   * Declare a function [name] with type [TYPE] in scope [s]
   */
  declareFunc : scope * string * TYPE
  declareFunc(s, name, type) :-
    {occs} // todo: remove
//    try { false } | note $[Declare func [name] in [s]: occs=[occs]], // todo: remove
    !func[name, type] in s,
    occs@resolveFunc(s, name) == [_]
      | error $[Duplicate definition of function [name]],
    @name.type := type.

  /**
   * Resolve a function [name] in scope [s]
   */
  resolveFunc : scope * string -> list((path * (string * TYPE)))
  resolveFunc(s, name) = occs :-
    query func
      filter P*
         and { name' :- name' == name }
         min $ < P
         and false
          in s |-> occs.

  /**
   * resolve a function [name] to a unique declaration in scope [s]
   */
  resolveUniqueFunc : scope * string -> TYPE
  resolveUniqueFunc(s, name) = ty :- {occs name'}
    resolveFunc(s, name) == occs,
    occs == [(_, (name', ty))],
    @name.ref := name',
    @name.type := ty,
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve function [name]] @name.


  /**
   * Declare a datatype [name] with scope [s_data] in scope [s]
   */
  declareDatatype : scope * string * scope
  declareDatatype(s, name, s_data) :-
    {occs} // todo: remove
//    try { false } | note $[Declare func [name] in [s]: occs=[occs]], // todo: remove
    !data[name, s_data] in s,
    occs@resolveDatatype(s, name) == [_]
      | error $[Duplicate definition of Datatype [name]],
    @name.type := DataType(name, s_data).

  /**
   * Resolve a datatype [name] in scope [s]
   */
  resolveDatatype : scope * string -> list((path * (string * scope)))
  resolveDatatype(s, name) = occs :-
    query data
      filter P*
         and { name' :- name' == name }
         min $ < P
         and false
          in s |-> occs.

  /**
   * resolve a datatype [name] to a unique declaration in scope [s]
   */
  resolveUniqueDatatype : scope * string -> scope
  resolveUniqueDatatype(s, name) = s_data :- {occs name'}
    resolveDatatype(s, name) == occs,
    occs == [(_, (name', s_data))],
    @name.ref := name',
    @name.type := DataType(name', s_data),
    // If there are multiple, the declaration will give an error.
    try { occs != [] } | error $[Could not resolve function [name]] @name.


  setContextType : scope * string * TYPE
  setContextType(s, name, ty) :-
    !context[name, ty] in s,
    true. // todo
//    getContextType(s, name) == _
//      | error $[Context value [name] is already set in [s]].

  getContextType : scope * string -> TYPE
  getContextType(s, name) = ty :- {occs}
    query context
      filter P*
         and { name' :- name' == name }
         min $ < P
         and true
          in s |-> occs,
    occs == [(_, (_, ty))],
    try { occs != [] } | error $[cannot get context value [name] in [s]].
