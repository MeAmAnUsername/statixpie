module statics/func_body

imports

  signatures/func_body-sig
  statics/base
  statics/type
  statics/util
  statics/binder

rules

  typeOfExp : scope * Exp -> TYPE
  typeOfExps maps typeOfExp(*, list(*)) = list(*)

// Blocks

  typeOfExp(s, Block2Exp(Block(exps))) = ty :- {s_block}
    new s_block,
    s_block -P-> s,
    typeOfBlockExps(s_block, exps) == ty.

  typeOfBlockExps : scope * list(Exp) -> TYPE
  typeOfBlockExps(s, [exp | exps@[_|_]]) = ty :-
    typeOfExp(s, exp) == _,
    typeOfBlockExps(s, exps) == ty.

  typeOfBlockExps(s, [exp | []]) = ty :-
    typeOfExp(s, exp) == ty.

// Unary expressions

  typeOfExp(s, ToNullable(exp)) = NullableType(ty) :-
    typeOfExp(s, exp) == ty,
    ty != NullableType(_) | error $[Type mismatch: expected non-nullable type, got [ty]] @exp.

  typeOfExp(s, ToNonNullable(exp)) = ty :-
    typeOfExp(s, exp) == NullableType(ty) | error $[Type mismatch: expected nullable type, got [ty]] @exp.

  typeOfExp(s, Not(exp)) = BoolType() :- {ty}
    expectSubtype(s, exp, BoolType()).

// Binary expressions

  /*
   * Body for Eq and Neq, since the statics are the same.
   * Takes a scope [s], left sub expression and right subexpression
   * It also uses the full expression for error reporting.
   */
  comparableOk : scope * Exp * Exp * Exp -> TYPE
  comparableOk(s, exp_left, exp_right, exp) = BoolType() :- {ty_left ty_right}
    typeOfExp(s, exp_left) == ty_left,
    typeOfExp(s, exp_right) == ty_right,
    soundComparable(ty_left, ty_right) == TRUE()| error $[Cannot compare [ty_left] to [ty_right]] @exp,
    try { soundButNotUnsoundComparable(ty_left, ty_right) == FALSE() } | warning $[Types can only be equal if they are null] @exp.

  typeOfExp(s, e@Eq(l, r)) = comparableOk(s, l, r, e).
  typeOfExp(s, e@Neq(l, r)) = comparableOk(s, l, r, e).

  typeOfExp(s, Lor(exp_left, exp_right)) = BoolType() :- {ty_left ty_right}
    expectSubtype(s, exp_left, BoolType()),
    expectSubtype(s, exp_right, BoolType()).

  typeOfExp(s, Land(exp_left, exp_right)) = BoolType() :- {ty_left ty_right}
    expectSubtype(s, exp_left, BoolType()),
    expectSubtype(s, exp_right, BoolType()).

  typeOfExp(s, Add(exp_left, exp_right)) = ty :- {ty_left ty_right}
    typeOfExp(s, exp_left) == ty_left,
    typeOfExp(s, exp_right) == ty_right,
    typeOfAdd(ty_left, ty_right) == ty | error $[Type mismatch: cannot add [ty_left] to [ty_right]].

  typeOfAdd : TYPE * TYPE -> TYPE
  typeOfAdd(IntType()      , IntType()      ) = IntType().
  typeOfAdd(StrType()      , _              ) = StrType().
  typeOfAdd(PathType()     , PathType()     ) = PathType().
  typeOfAdd(PathType()     , StrType()      ) = PathType().
  typeOfAdd(ListType(T)    , ListType(T)    ) = ListType(T).
  typeOfAdd(ListType(T)    , NullType()     ) = ListType(makeNullable(T)).
  typeOfAdd(ListType(T1)   , T2             ) = ListType(T1) :- subtype(T2, T1).
  typeOfAdd(EmptyListType(), ListType(T)    ) = ListType(T).
  typeOfAdd(EmptyListType(), EmptyListType()) = EmptyListType().
  typeOfAdd(EmptyListType(), T              ) = ListType(T).

// Control flow

  typeOfExp(s, If(exp_cond, exp_body)) = UnitType() :- {ty_cond}
    expectSubtype(s, exp_cond, BoolType()),
    typeOfExp(s, exp_body) == _.

  typeOfExp(s, IfElse(exp_cond, exp_true, exp_false)) = ty :- {ty_cond ty_true ty_false}
    expectSubtype(s, exp_cond, BoolType()),
    typeOfExp(s, exp_true) == ty_true,
    typeOfExp(s, exp_false) == ty_false,
    lub(ty_true, ty_false) == ty,
    try { ty != TopType() } | warning $[Type mismatch: true branch ([ty_true]) and false branch ([ty_false]) combine to the top type. Are you sure?].

 typeOfExp(s, ListComprehension(exp_map, binder, exp_list)) = ListType(ty_map) :- {ty_list expected_ty s_comprehension ty_arg}
   ty_list == typeOfExp(s, exp_list),
   subtype(ty_list, expected_ty@ListType(ty_arg)) | error $[Type mismatch: expected [expected_ty], got [ty_list]] @exp_list,
   try { ty_list != EmptyListType() } | warning $[Dead code: list comprehension over empty list] @exp_list,
   // todo: better error messages
   // If not a list: expected a list
   // If Empty list: dead code
   // If non-empty list but wrong element type: wrong element type
   new s_comprehension,
   s_comprehension -P-> s,
   typeOfBinder(s_comprehension, ty_arg, binder) == _,
   typeOfExp(s_comprehension, exp_map) == ty_map.

// Value declaration and use.
  
  typeOfExp(s, ValDec(binder, exp)) = declared_ty :- {actual_ty}
    typeOfExp(s, exp) == actual_ty,
    typeOfBinder(s, actual_ty, binder) == declared_ty.

  typeOfExp(s, Ref2Exp(Ref(name))) = resolveUniqueVal(s, name).

// Calls

  /**
   * Checks that a call is Ok, returns the return type of the function.
   * - resolve function [name] in scope [s_data].
   * - Check that [arg_exps] have the right types (resolved in scope [s])
   * This is a general function to check any type of call.
   * The caller just needs to provide s_data.
   */
  typeOfCall : scope * scope * string * list(Exp) -> TYPE
  typeOfCall(s, s_data, name, arg_exps) = out_ty :- {param_tys arg_tys}
    resolveUniqueFunc(s_data, name) == FuncType(param_tys, out_ty),
    expectSubtypes(s, arg_exps, param_tys).

  typeOfExp(s, Call(name, arg_exps)) = typeOfCall(s, s, name, arg_exps).

  typeOfExp(s, QCall(exp, name, arg_exps)) = ty :- {exp_ty s_data}
    typeOfExp(s, exp) == exp_ty,
    false | error "todo: QCall statics",
    // getScopeFromType(exp_ty) == s_data, // todo
    typeOfCall(s, s_data, name, arg_exps) == ty.

  typeOfExp(s, ImportCall(moduleList, name, arg_exps)) = ty :- {s_data}
    // todo: resolve module list to s_data
    false | error "todo: ImportCall statics",
    typeOfCall(s, s_data, name, arg_exps) == ty.

  // todo: CreateSupplier, TaskSupplier, SupplierGet
  
// Path operations

  optionalStamperOk : scope * list(StamperPart)
  optionalStamperOk(s, []).
  optionalStamperOk(s, [StamperPart(stampKind)]) :- stamperOk(s, stampKind).

  stamperOk : scope * StampKind
  stamperOk(s, Modified()).
  stamperOk(s, Hash()).
  
  optionalFilterOk: scope * list(FilterPart)
  optionalFilterOk(s, []).
  optionalFilterOk(s, [FilterPart(filter)]) :- filterOk(s, filter).

  filterOk : scope * Filter
  filterOk(s, Regex(exp))      :- expectSubtype(s, exp, StrType()).
  filterOk(s, Pattern(exp))    :- expectSubtype(s, exp, StrType()).
  filterOk(s, Patterns(exp))   :- expectSubtype(s, exp, ListType(StrType())).
  filterOk(s, Extension(exp))  :- expectSubtype(s, exp, StrType()).
  filterOk(s, Extensions(exp)) :- expectSubtype(s, exp, ListType(StrType())).


  typeOfExp(s, RequiresPath(exp, filter, stamper)) = UnitType() :- {exp_ty}
    expectSubtype(s, exp, PathType()),
    optionalFilterOk(s, filter),
    optionalStamperOk(s, stamper).

  typeOfExp(s, GeneratesPath(exp, stamper)) = UnitType() :-
    expectSubtype(s, exp, PathType()),
    optionalStamperOk(s, stamper).

  typeOfExp(s, ListPath(exp, filter)) = ListType(PathType()) :-
    expectSubtype(s, exp, PathType()),
    optionalFilterOk(s, filter).

  typeOfExp(s, WalkPath(exp, filter)) = ListType(PathType()) :-
    expectSubtype(s, exp, PathType()),
    optionalFilterOk(s, filter).

  typeOfExp(s, ReadPath(exp)) = NullableType(StrType()) :-
    expectSubtype(s, exp, PathType()).
  
  typeOfExp(s, ExistsPath(exp)) = BoolType() :-
    expectSubtype(s, exp, PathType()).
  
// Early return and failure

  typeOfExp(s, Return(exp)) = UnitType() :- {expected_ty}
    getContextType(s, "func_return_ty") == expected_ty,
    expectSubtype(s, exp, expected_ty).
    
  typeOfExp(s, Fail(exp)) = UnitType() :-
    expectSubtype(s, exp, StrType()).

// literals

  typeOfExp(s, UnitLit())  = UnitType().
  typeOfExp(s, BoolLit(_)) = BoolType().
  typeOfExp(s, IntLit(_))  = IntType().
  typeOfExp(s, NullLit())  = NullType().
  typeOfExp(s, TupleLit(exps)) = TupleType(typeOfExps(s, exps)).  
  
  typeOfExp(s, ListLit([])) = EmptyListType().
  typeOfExp(s, ListLit(exps)) = ListType(listLub(typeOfExps(s, exps))).

// String literals

  strPartOk : scope * StrPart
  strPartsOk maps strPartOk(*, list(*))
  strPartOk(s, Str(_)).
  strPartOk(s, StrInterpRef(Ref(name))) :- resolveUniqueVal(s, name) == _.
  strPartOk(s, StrInterpExp(exp)) :- typeOfExp(s, exp) == _.

  typeOfExp(s, StrLit(parts)) = StrType() :- strPartsOk(s, parts).

// Path literals

  pathPartOk : scope * PathPart
  pathPartsOk maps pathPartOk(*, list(*))
  pathPartOk(s, Path(_)).
  pathPartOk(s, PathInterpRef(Ref(name))) :- resolveUniqueVal(s, name) == _.
  pathPartOk(s, PathInterpExp(exp)) :- typeOfExp(s, exp) == _.

  typeOfExp(s, PathLit(_, parts)) = PathType() :- pathPartsOk(s, parts).
